调研自动化埋点分享

# 1：埋点分类

(1) 代码埋点：在某个事件发生时调用SDK里面相应的接口发送埋点数据，百度统计、友盟、TalkingData、Sensors Analytics等第三方数据统计服务商大都采用这种方案。

- 优点：使用者控制精准，自由地选择什么时候发送数据。

- 缺点：开发及测试代价大；需要等待APP更新。

(2) 可视化埋点：通过可视化工具配置采集节点，在Android端自动解析配置并上报埋点数据，从而实现所谓的自动埋点，代表方案是已经开源的Mixpanel。

- 优点：解放开发人员，解决了代码埋点代价大的问题；通过服务端配置埋点，解决等待APP更新的问题。

- 缺点：覆盖功能有限，只能配置一些公共属性；

(3) 无埋点：它并不是真正的不需要埋点，而是Android端自动采集全部事件并上报埋点数据，在后端数据计算时过滤出有用数据，代表方案是国内的GrowingIO。

- 优点：解放开发人员，解决了代码埋点代价大的问题

- 缺点：覆盖的功能有限，不能灵活地自定义属性；给网络传输和耗电等性能带来更大的负载。

# 2：业内方案：

## 网易HubbleData：

1：View标识 唯一ID (路径) 后端映射具体控件

深度路径

![img](../../../art/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%8B%E7%82%B9%E5%88%86%E4%BA%AB/-164266192033819.png)

优化：

![img](../../../art/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%8B%E7%82%B9%E5%88%86%E4%BA%AB/-16426619203361.png)



2：代理android 原生方法：

```
onClick(Landroid/view/View;)V
onClick(Landroid/content/DialogInterface;I)V
onItemClick(Landroid/widget/AdapterView;Landroid/view/View;IJ)V
onItemSelected(Landroid/widget/AdapterView;Landroid/view/View;IJ)V
onGroupClick(Landroid/widget/ExpandableListView;Landroid/view/View;IJ)Z
onChildClick(Landroid/widget/ExpandableListView;Landroid/view/View;IIJ)Z
onRatingChanged(Landroid/widget/RatingBar;FZ)V
onStopTrackingTouch(Landroid/widget/SeekBar;)V
onCheckedChanged(Landroid/widget/CompoundButton;Z)V
onCheckedChanged(Landroid/widget/RadioGroup;I)V
```

## MixPanel：（可视化埋点）

开源地址：（参考代码）使用收费

不支持在 Docs 外粘贴 block

## https://github.com/mixpanel/mixpanel-android#quick-start-guide

![img](../../../art/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%8B%E7%82%B9%E5%88%86%E4%BA%AB/-16426619203362.png)







## 美团MTFlexbox（参考了 HubbleData + MixPanel）

![img](../../../art/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%8B%E7%82%B9%E5%88%86%E4%BA%AB/-16426619203363.png)





整体流程



MTFlexbox自动化埋点的核心流程，分为以下五步：

1. 客户端开发人员根据设计稿开发XML样式文件，自测通过后将XML样式文件与接口数据上传至MTFlexbox管理后台。
2. MTFlexbox管理后台自动连接远程移动设备，并发送布局处理命令。远程移动设备将布局渲染结束后，抓取截图和布局层级信息（包括控件父子关系、控件位置、大小等信息）并上传至管理后台。
3. 前端页面从后台拿到DPath路径信息、坐标信息和截图信息，提供一套可视化的界面供数据同学进行模块内任一控件的埋点圈选配置。数据同学根据自身的需求，从目录树中圈选出自己希望配置埋点的控件。如下图所示，右侧模块中会出现红圈将选中的控件标出。

![img](../../../art/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%8B%E7%82%B9%E5%88%86%E4%BA%AB/-16426619203364.png)



目录树圈选控件

1. 选中某个控件之后，数据同学对该控件进行埋点配置，元素类型支持当前元素和同类元素。其中同类元素可以节省数据同学对于同一种类型的控件的多次配置。对于已经圈选出的控件，列表中会详细展示出相关的信息，并附上控件对于的位置截图，能够方便数据RD定位埋点的控件具体位置。

![img](../../../art/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%8B%E7%82%B9%E5%88%86%E4%BA%AB/-16426619203365.png)



埋点配置

1. MTFlexbox管理后台根据前端上报的埋点信息，生成包含业务埋点的XML样式文件，供C端业务方后台调用。

```
<?xml version="1.0" encoding="UTF-8"?>
<Container>
    <Var auto-mge="true" name="ff510aa110844bb78c0b86fb04b26460" type="json">
        {
            "bid" : "xxxxx",
            "cid" : "sssss",
            "lab" : {
                "index" : "{_index}",
            }
        }
    </Var>

    <!-- 整个容器 -->
    <Container background="#FFFFFF" border-radius="10pt"
        click-mge4-report="{ff510aa110844bb78c0b86fb04b26460}"
        click-url="{_iUrl}" padding-left="10pt" padding-right="10pt">
        <!-- 左半部分 -->
        <Container style="flex-direction:column;justify-content:flex-start;margin-top:15pt;">
```

1. 当客户端请求业务后台时，业务后台将包含业务埋点的XML样式文件下发给客户端，客户端根据配置完成埋点信息上报。

# 3：技术支持 

## 思考：针对APP | 广告 我们有了参考思路，我们如何去做？

## 1：手动埋点方案：

人力成本高；灵活

## 2：代理埋点

####      1：hook 手动

​       开发量比较大

####      2：自动化生成代码

​      优点明显，如何来做？

## 3：自动化埋点基础实践

### 1：AOP

全称“Aspect Oriented Programming”,面向切面编程，由于面向对象的思想要求高内聚，低耦合的风格，使模块代码间的可见性变差，对于埋点，日志输出等需求，就会变的十分复杂，如果手动编写代码，入侵性很大，不利于扩展，AOP应运而生。

AspectJ

AspectJ实际上是对AOP编程的实践，目前还有很多的AOP实现，如ASMDex，但笔者选用的是AspectJ。

使用场景

当我们需要在某个方法运行前和运行后做一些处理时，便可使用AOP技术。具体有：

- 统计埋点

- 日志打印/打点

- 数据校验

- 行为拦截

- 性能监控

- 动态权限控制

### 2:Android AOP 基础

#### 1：Android 打包流程

![img](../../../art/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%8B%E7%82%B9%E5%88%86%E4%BA%AB/-16426619203366.png)

#### 2：android gradle Task 解读

插件：com.android.tools.build:gradle:4.2.2 

项目引用：

```
plugins {
    id 'com.android.application'
}
```

android 插件源码：

##### 入口：

```
/** Base class for all Android plugins */
public abstract class BasePlugin<
                AndroidComponentsT extends
                        AndroidComponentsExtension<? extends ComponentBuilder, ? extends Variant>,
                VariantBuilderT extends VariantBuilderImpl,
                VariantT extends VariantImpl>
        implements Plugin<Project>, LintModelModuleLoaderProvider {
            ..........................
     //入口 
    @Override
    public final void apply(@NonNull Project project) {
        CrashReporting.runAction(
                () -> {
                    basePluginApply(project);//主要
                    pluginSpecificApply(project);
                });
    }       
}

//主要函数
private void basePluginApply(@NonNull Project project) {
        // We run by default in headless mode, so the JVM doesn't steal focus.
        System.setProperty("java.awt.headless", "true");

        this.project = project;

        new AnalyticsService.RegistrationAction(project).execute();

        configuratorService
                = new AnalyticsConfiguratorService.RegistrationAction(project).execute().get();

        optionService = new ProjectOptionService.RegistrationAction(project).execute().get();

        createProjectServices(project);

        ProjectOptions projectOptions = projectServices.getProjectOptions();

        DependencyResolutionChecks.registerDependencyCheck(project, projectOptions);

        project.getPluginManager().apply(AndroidBasePlugin.class);


        checkPathForErrors();
        checkModulesForErrors();

        AgpVersionChecker.enforceTheSamePluginVersions(project);

        String attributionFileLocation =
                projectOptions.get(StringOption.IDE_ATTRIBUTION_FILE_LOCATION);
        if (attributionFileLocation != null) {
            new BuildAttributionService.RegistrationAction(project).execute();
            BuildAttributionService.Companion.init(
                    project, attributionFileLocation, listenerRegistry);
        }

        configuratorService.createAnalyticsService(project, listenerRegistry);

        configuratorService.getProjectBuilder(project.getPath())
                .setAndroidPluginVersion(Version.ANDROID_GRADLE_PLUGIN_VERSION)
                .setAndroidPlugin(getAnalyticsPluginType())
                .setPluginGeneration(GradleBuildProject.PluginGeneration.FIRST)
                .setOptions(AnalyticsUtil.toProto(projectOptions));

        configuratorService.recordBlock(
                ExecutionType.BASE_PLUGIN_PROJECT_CONFIGURE,
                project.getPath(),
                null,
                this::configureProject);

        configuratorService.recordBlock(
                ExecutionType.BASE_PLUGIN_PROJECT_BASE_EXTENSION_CREATION,
                project.getPath(),
                null,
                this::configureExtension);//配置信息

        configuratorService.recordBlock(
                ExecutionType.BASE_PLUGIN_PROJECT_TASKS_CREATION,
                project.getPath(),
                null,
                this::createTasks);//组装task任务
    }
```

###### 配置信息：

```
private void configureExtension() {
        DslServices dslServices = globalScope.getDslServices();

        final NamedDomainObjectContainer<BaseVariantOutput> buildOutputs =
                project.container(BaseVariantOutput.class);

        project.getExtensions().add("buildOutputs", buildOutputs);

        variantFactory = createVariantFactory(projectServices, globalScope);

        variantInputModel =
                new LegacyVariantInputManager(
                        dslServices,
                        variantFactory.getVariantType(),
                        new SourceSetManager(
                                project,
                                isPackagePublished(),
                                dslServices,
                                new DelayedActionsExecutor()));

        extension =
                createExtension(
                        dslServices, globalScope, variantInputModel, buildOutputs, extraModelInfo);// 配置信息在这里  AppPlugin 来实现

        globalScope.setExtension(extension);

        VariantApiOperationsRegistrar<VariantBuilderT, VariantT> variantApiOperations =
                new VariantApiOperationsRegistrar<>();
        androidComponentsExtension = createComponentExtension(dslServices, variantApiOperations);

        variantManager =
                new VariantManager(
                        globalScope,
                        project,
                        projectServices.getProjectOptions(),
                        extension,
                        variantApiOperations,
                        variantFactory,
                        variantInputModel,
                        projectServices);

        registerModels(
                registry,
                globalScope,
                variantInputModel,
                extension,
                extraModelInfo);

        // create default Objects, signingConfig first as its used by the BuildTypes.
        variantFactory.createDefaultComponents(variantInputModel);

        createAndroidTestUtilConfiguration();
    }
public class AppPlugin extends AbstractAppPlugin<ApplicationAndroidComponentsExtension,ApplicationVariantBuilderImpl,ApplicationVariantImpl> {
                ...
     @NonNull
    @Override
    protected BaseExtension createExtension(
            @NonNull DslServices dslServices,
            @NonNull GlobalScope globalScope,
            @NonNull
                    DslContainerProvider<DefaultConfig, BuildType, ProductFlavor, SigningConfig>
                            dslContainers,
            @NonNull NamedDomainObjectContainer<BaseVariantOutput> buildOutputs,
            @NonNull ExtraModelInfo extraModelInfo) {
        if (globalScope.getProjectOptions().get(BooleanOption.USE_NEW_DSL_INTERFACES)) {
            return (BaseExtension)
                    project.getExtensions()
                            .create(
                                    ApplicationExtension.class,//参考android 配置
                                    "android",
                                    BaseAppModuleExtension.class,
                                    dslServices,
                                    globalScope,
                                    buildOutputs,
                                    dslContainers.getSourceSetManager(),
                                    extraModelInfo,
                                    new ApplicationExtensionImpl(dslServices, dslContainers));
        }
        return project.getExtensions()
                .create(
                        "android",
                        BaseAppModuleExtension.class,
                        dslServices,
                        globalScope,
                        buildOutputs,
                        dslContainers.getSourceSetManager(),
                        extraModelInfo,
                        new ApplicationExtensionImpl(dslServices, dslContainers));
    }
    ...
}
//最终配置类
@Incubating
interface ApplicationBaseFlavor<SigningConfigT : SigningConfig> :
    BaseFlavor,
    ApplicationVariantDimension<SigningConfigT> {
    /**
     * The application ID.
     *
     * See [Set the Application ID](https://developer.android.com/studio/build/application-id.html)
     */
    var applicationId: String?

    /**
     * Version code.
     *
     * See [Versioning Your Application](http://developer.android.com/tools/publishing/versioning.html)
     */
    var versionCode: Int?

    /**
     * Version name.
     *
     * See [Versioning Your Application](http://developer.android.com/tools/publishing/versioning.html)
     */
    var versionName: String?

    /**
     * The target SDK version.
     * Setting this it will override previous calls of [targetSdk] and [targetSdkPreview] setters.
     * Only one of [targetSdk] and [targetSdkPreview] should be set.
     *
     * See [uses-sdk element documentation](http://developer.android.com/guide/topics/manifest/uses-sdk-element.html).
     */
    var targetSdk: Int?

    /**
     * The target SDK version.
     * Setting this it will override previous calls of [targetSdk] and [targetSdkPreview] setters.
     * Only one of [targetSdk] and [targetSdkPreview] should be set.
     *
     * See [uses-sdk element documentation](http://developer.android.com/guide/topics/manifest/uses-sdk-element.html).
     */
    var targetSdkPreview: String?

    /**
     * The maxSdkVersion, or null if not specified. This is only the value set on this produce
     * flavor.
     *
     * See [uses-sdk element documentation](http://developer.android.com/guide/topics/manifest/uses-sdk-element.html).
     */
    var maxSdk: Int?
}
```

###### Task任务：

```
  private void createTasks() {
        configuratorService.recordBlock(
                ExecutionType.TASK_MANAGER_CREATE_TASKS,
                project.getPath(),
                null,
                () ->
                        TaskManager.createTasksBeforeEvaluate(
                                globalScope,
                                variantFactory.getVariantType(),
                                extension.getSourceSets()));

        project.afterEvaluate(
                CrashReporting.afterEvaluate(
                        p -> {
                            variantInputModel.getSourceSetManager().runBuildableArtifactsActions();

                            configuratorService.recordBlock(
                                    ExecutionType.BASE_PLUGIN_CREATE_ANDROID_TASKS,
                                    project.getPath(),
                                    null,
                                    this::createAndroidTasks);//创建任务
                        }));
    }
    
```



```
 final void createAndroidTasks() {
 ...
     //编译配置
         configuratorService.getProjectBuilder(project.getPath())
                .setCompileSdk(extension.getCompileSdkVersion())
                .setBuildToolsVersion(extension.getBuildToolsRevision().toString())
                .setSplits(AnalyticsUtil.toProto(extension.getSplits()));

     //kotlin
        String kotlinPluginVersion = getKotlinPluginVersion();
        if (kotlinPluginVersion != null) {
            configuratorService.getProjectBuilder(project.getPath())
                    .setKotlinPluginVersion(kotlinPluginVersion);
        }
        AnalyticsUtil.recordFirebasePerformancePluginVersion(project);

        // create the build feature object that will be re-used everywhere
     //扩展功能 viewBinding  dataBinding
        BuildFeatureValues buildFeatureValues =
                variantFactory.createBuildFeatureValues(
                        extension.getBuildFeatures(), projectServices.getProjectOptions());

             //创建变体
        variantManager.createVariants(buildFeatureValues, extension.getNamespace());

        List<ComponentInfo<VariantBuilderT, VariantT>> variants =
                variantManager.getMainComponents();

     //创建Task
        TaskManager<VariantBuilderT, VariantT> taskManager =
                createTaskManager(
                        variants,
                        variantManager.getTestComponents(),
                        !variantInputModel.getProductFlavors().isEmpty(),
                        globalScope,
                        extension);

        taskManager.createTasks(variantFactory.getVariantType(), buildFeatureValues);
     
 }
  public class AppPlugin
        extends AbstractAppPlugin<
                ApplicationAndroidComponentsExtension,
                ApplicationVariantBuilderImpl,
                ApplicationVariantImpl> {
                    ....
    @Inject
  @NonNull
    @Override //app Task 任务
    protected ApplicationTaskManager createTaskManager(
            @NonNull
                    List<ComponentInfo<ApplicationVariantBuilderImpl, ApplicationVariantImpl>>
                            variants,
            @NonNull
                    List<ComponentInfo<TestComponentBuilderImpl, TestComponentImpl>> testComponents,
            boolean hasFlavors,
            @NonNull GlobalScope globalScope,
            @NonNull BaseExtension extension) {
        return new ApplicationTaskManager(
                variants, testComponents, hasFlavors, globalScope, extension);//真实创建任务
    }
                    ...
    }
```



```
protected void createCommonTasks(
            @NonNull ComponentInfo<VariantBuilderT, VariantT> variant,
            @NonNull
                    List<? extends ComponentInfo<VariantBuilderT, VariantT>>
                            allComponentsWithLint) {
        VariantT appVariantProperties = variant.getVariant();
        ApkCreationConfig apkCreationConfig = (ApkCreationConfig) appVariantProperties;

        createAnchorTasks(appVariantProperties);

        taskFactory.register(new ExtractDeepLinksTask.CreationAction(appVariantProperties));

        // Create all current streams (dependencies mostly at this point) 依赖包
        createDependencyStreams(appVariantProperties);

        // Add a task to publish the applicationId.
        // TODO remove case once TaskManager's type param is based on BaseCreationConfig
        createApplicationIdWriterTask(apkCreationConfig);

        // Add a task to check the manifest
        taskFactory.register(new CheckManifest.CreationAction(appVariantProperties));

        // Add a task to process the manifest(s)//合并APK 清单
        createMergeApkManifestsTask(appVariantProperties);

        // Add a task to create the res values
        createGenerateResValuesTask(appVariantProperties);

        // Add a task to compile renderscript files.
        createRenderscriptTask(appVariantProperties);

        // Add a task to merge the resource folders //资源文件
        createMergeResourcesTasks(appVariantProperties);

        // Add tasks to compile shader
        createShaderTask(appVariantProperties);

        // Add a task to merge the asset folders
        createMergeAssetsTask(appVariantProperties);

        taskFactory.register(new CompressAssetsTask.CreationAction(apkCreationConfig));

        // Add a task to create the BuildConfig class
        createBuildConfigTask(appVariantProperties);

        // Add a task to process the Android Resources and generate source files
        createApkProcessResTask(appVariantProperties);

        registerRClassTransformStream(appVariantProperties);

        // Add a task to process the java resources
        createProcessJavaResTask(appVariantProperties);

        createAidlTask(appVariantProperties);

        // Add external native build tasks
        createExternalNativeBuildTasks(appVariantProperties);

        maybeExtractProfilerDependencies(apkCreationConfig);

        // Add a task to merge the jni libs folders
        createMergeJniLibFoldersTasks(appVariantProperties);

        // Add data binding tasks if enabled
        createDataBindingTasksIfNecessary(appVariantProperties);

        // Add a task to auto-generate classes for ML model files.
        createMlkitTask(appVariantProperties);

        // Add a compile task --- 会创建dex Task
        createCompileTask(appVariantProperties);

        taskFactory.register(new StripDebugSymbolsTask.CreationAction(appVariantProperties));

        taskFactory.register(
                new ExtractNativeDebugMetadataTask.FullCreationAction(appVariantProperties));
        taskFactory.register(
                new ExtractNativeDebugMetadataTask.SymbolTableCreationAction(appVariantProperties));

        createPackagingTask(apkCreationConfig);

        maybeCreateLintVitalTask(appVariantProperties, allComponentsWithLint);

        // Create the lint tasks, if enabled
        createLintTasks(appVariantProperties, allComponentsWithLint);

        taskFactory.register(
                new PackagedDependenciesWriterTask.CreationAction(appVariantProperties));

        taskFactory.register(new ApkZipPackagingTask.CreationAction(appVariantProperties));
    }
```

我们要看的重点：

```
private void createCompileTask(@NonNull VariantImpl variant) {
    ApkCreationConfig apkCreationConfig = (ApkCreationConfig) variant;

    TaskProvider<? extends JavaCompile> javacTask = createJavacTask(variant);
    addJavacClassesStream(variant);
    setJavaCompilerTask(javacTask, variant);
    createPostCompilationTasks(apkCreationConfig);//重要
}
```

先走transform  后有 dex

```
  fun createPostCompilationTasks(creationConfig: ApkCreationConfig) {
                  ..............
            
        // ----- External Transforms -----
        // apply all the external transforms.
        val customTransforms = extension.transforms//这里就是插件注册transforms
        val customTransformsDependencies = extension.transformsDependencies
        var registeredLegacyTransform = false
     
              ...............
            
         //组装DEX文件
        createDexTasks(creationConfig, dexingType, registeredLegacyTransform)
        maybeCreateResourcesShrinkerTasks(creationConfig)
        maybeCreateDexSplitterTask(creationConfig)
  }
```

#### 3：gradle插件

1：新建library 删除无用 （除去andorid 相关的）



2：创建resources 文件 固定格式

![img](../../../art/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%8B%E7%82%B9%E5%88%86%E4%BA%AB/-16426619203367.png)

.properties 之前的就是你的插件名称

内容：implementation-class=com.miadapm.plugin.MiAdApmPlugin //插件入口类

3：插件gradle配置：

```
apply plugin: 'groovy'//语言
apply plugin: 'maven'//仓库

dependencies {
    implementation gradleApi()
    implementation localGroovy()
    implementation 'com.android.tools.build:gradle:4.2.2'
    implementation 'org.ow2.asm:asm:7.1'
    implementation 'org.ow2.asm:asm-commons:7.1'
    implementation 'org.aspectj:aspectjrt:1.9.7'
    implementation 'org.aspectj:aspectjtools:1.9.7'
}

repositories {
    mavenCentral()
}


def group='com.miadapm.plugin' //组
def version='1.0.0' //版本
def artifactId='miadapm' //唯一标示


//将插件打包上传到本地maven仓库
uploadArchives {
    repositories {
        mavenDeployer {
            pom.groupId = group
            pom.artifactId = artifactId
            pom.version = version
            //指定本地maven的路径，在项目根目录下
            repository(url: uri('../repos'))
        }
    }
}
```

project gradle 配置：

```
// Top-level build file where you can add configuration options common to all sub-projects/modules.
buildscript {
    repositories {
        maven {
            url uri('./repos')
        }
        mavenLocal()
        google()
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:4.2.2'
        classpath 'com.miadapm.plugin:miadapm:1.0.0'
        classpath 'org.aspectj:aspectjtools:1.9.7'
    }
}

allprojects {
    repositories {
        maven {
            url uri('./repos')
        }
        mavenLocal()
        google()
        jcenter()
    }
}


task clean(type: Delete) {
    delete rootProject.buildDir
}
```

使用：

```
classpath 'com.miadapm.plugin:miadapm:1.0.0'
apply plugin: 'xxxx'//插件名称
```

实现类：

```
package com.miadapm.plugin;

//gradle 插件入口
public class MiAdApmPlugin implements Plugin<Project> {

    @Override
    public void apply(Project project) {
    }
```

重点：

1：android 使用 transform 来进行 class -- > dex 中间进行处理

2：也可以在Java 编译为 class 后，执行Task 任务进行处理

举例一：

```
public class MiAdApmPlugin implements Plugin<Project> {

    @Override
    public void apply(Project project) {
        AsmStart(project)
    }


    private void AsmStart(Project project) {
        System.out.println("================ ASM Plugin start =============");
        AppExtension appExtension = (AppExtension) project.getProperties().get("android");
        appExtension.registerTransform(new AsmTransform(), Collections.EMPTY_LIST);
    }
    }
```



***重点*****

```
package com.miadapm.plugin.asm;

import com.android.build.api.transform.Format;
import com.android.build.api.transform.QualifiedContent;
import com.android.build.api.transform.Transform;
import com.android.build.api.transform.TransformException;
import com.android.build.api.transform.TransformInvocation;
import com.android.build.gradle.internal.pipeline.TransformManager;
import com.android.utils.FileUtils

class AsmTransform extends Transform {

    private final String TAG = "ASM-TransFor";

    @Override
    String getName() {
        return TAG
    }

    @Override
    Set<QualifiedContent.ContentType> getInputTypes() {
        return TransformManager.CONTENT_CLASS
    }

    @Override
    Set<? super QualifiedContent.Scope> getScopes() {
        return TransformManager.SCOPE_FULL_PROJECT
    }

    @Override
    boolean isIncremental() {
        return false
    }

    @Override
    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {
        super.transform(transformInvocation);
        //当前是否是增量编译
        boolean isIncremental = transformInvocation.isIncremental();
        System.out.println("current is incremental = " + isIncremental);
        //消费型输入，可以从中获取jar包和class文件夹路径。需要输出给下一个任务
        def inputs = transformInvocation.getInputs();
        //引用型输入，无需输出。
        def referencedInputs = transformInvocation.getReferencedInputs();
        //OutputProvider管理输出路径，如果消费型输入为空，你会发现OutputProvider == null
        def outputProvider = transformInvocation.getOutputProvider();

        inputs.forEach() {
            it.jarInputs.forEach() { jarInput ->
                def dest = outputProvider.getContentLocation(jarInput.file.absolutePath, jarInput.contentTypes, jarInput.scopes, Format.JAR);
                def inputFile = jarInput.file
                println(TAG + " :skip jar is" + inputFile.getPath() + inputFile.getName());
                FileUtils.copyFile(inputFile, dest);
            }
            it.directoryInputs.forEach() { dirInput ->
                def dest = outputProvider.getContentLocation(dirInput.file.absolutePath, dirInput.contentTypes, dirInput.scopes, Format.DIRECTORY);
                def dirInputFile = dirInput.file
                if (dirInputFile.isDirectory()) {
                    dirInputFile.eachFileRecurse { inputClassFile ->
                        println(TAG + " :action class is" + inputClassFile.getPath() + inputClassFile.getName());
                        if(inputClassFile.name.endsWith("class")){
                            AsmMethodMonitor.addMonitorByteCode(inputClassFile)
                        }
                    }
                } else {
                    println(TAG + " :action class is" + dirInputFile.getPath() + dirInputFile.getName());
                }
                FileUtils.copyDirectory(dirInputFile, dest)
            }
        }
    }
}
```



### 3:AOP 方案基础入门

#### 1：Javassit

##### 1：Javassist是什么

Javassist是可以动态编辑Java字节码的类库。它可以在Java程序运行时定义一个新的类，并加载到JVM中；还可以在JVM加载时修改一个类文件。Javassist使用户不必关心字节码相关的规范也是可以编辑类文件的。

##### 2：Javassist核心API

在Javassist中每个需要编辑的class都对应一个CtCLass实例，CtClass的含义是编译时的类（compile time class），这些类会存储在Class Pool中（Class poll是一个存储CtClass对象的容器）。

 CtClass中的CtField和CtMethod分别对应Java中的字段和方法。通过CtClass对象即可对类新增字段和修改方法等操作了。

![img](../../../art/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%8B%E7%82%B9%E5%88%86%E4%BA%AB/-16426619203368.png)



###### ClassPool

1. getDefault : 返回默认的

`ClassPool` 是单例模式的，一般通过该方法创建我们的ClassPool；

1. appendClassPath, insertClassPath : 将一个

`ClassPath`加到类搜索路径的末尾位置 或 插入到起始位置。通常通过该方法写入额外的类搜索路径，以解决多个类加载器环境中找不到类的尴尬；

1. toClass : 将修改后的CtClass加载至当前线程的上下文类加载器中，CtClass的

`toClass`方法是通过调用本方法实现。**需要注意的是一旦调用该方法，则无法继续修改已经被加载的class**；

1. get , getCtClass : 根据类路径名获取该类的CtClass对象，用于后续的编辑。

###### `CtClass`

1. freeze : 冻结一个类，使其不可修改；
2. isFrozen : 判断一个类是否已被冻结；
3. prune : 删除类不必要的属性，以减少内存占用。调用该方法后，许多方法无法将无法正常使用，慎用；
4. defrost : 解冻一个类，使其可以被修改。如果事先知道一个类会被defrost， 则禁止调用 prune 方法；
5. detach : 将该class从ClassPool中删除；
6. writeFile : 根据CtClass生成 

`.class` 文件；

1. toClass : 通过类加载器加载该CtClass。

上面我们创建一个新的方法使用了

`CtMethod`类。CtMthod代表类中的某个方法，可以通过CtClass提供的API获取或者CtNewMethod新建，通过CtMethod对象可以实现对方法的修改。

###### `CtMethod`

1. insertBefore : 在方法的起始位置插入代码；
2. insterAfter : 在方法的所有 return 语句前插入代码以确保语句能够被执行，除非遇到exception；
3. insertAt : 在指定的位置插入代码；
4. setBody : 将方法的内容设置为要写入的代码，当方法被 abstract修饰时，该修饰符被移除；
5. make : 创建一个新的方法。

##### 3：eg

1：创建一个测试类，代码如下：

```
package com.ssdmbbl.javassist;

import javassist.*;

import java.io.IOException;

public class JavassistTest {
    public static void main(String[] args) throws CannotCompileException, IOException {
        ClassPool cp = ClassPool.getDefault();
        CtClass ctClass = cp.makeClass("com.ssdmbbl.javassist.Hello");
        ctClass.writeFile("./");
    }
}
```

![img](../../../art/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%8B%E7%82%B9%E5%88%86%E4%BA%AB/-16426619203379.png)

2：米盟聚合sdk使用：规避开放接口

```
package com.transform.mediationplugin

import com.xiaomi.mediationannotation.HideClass
import com.xiaomi.mediationannotation.HideMethod
import javassist.ClassPool
import javassist.CtClass
import javassist.CtMethod
import org.gradle.api.Project

public class MediationRemoveMethod {
    private final static ClassPool pool = ClassPool.getDefault();

    public static void inject(String path, Project project) {
        pool.appendClassPath(path)
        File dir = new File(path)
        println("file path =="+ dir.getAbsolutePath())
        if (dir.isDirectory()) {
            dir.eachFileRecurse { File file ->
                try {
                    if (file.getName().endsWith("class") && file.exists()) {
                        InputStream io = new FileInputStream(file)
                        CtClass ctClass = pool.makeClass(io)
                        if (ctClass.isFrozen()) {
                            ctClass.defrost()
                        }
                        HideClass classAnnotation = ctClass.getAnnotation(HideClass.class)
                        if (classAnnotation == null ){
                            ctClass.detach()
                            return
                        }
                        if(classAnnotation.value()){
                            ctClass.detach()
                            io.close()
                            boolean delete = file.delete()
                            println(" remove class success : "+delete+"\n class info :"+ctClass.toString())
                            return
                        }
                        println(" change class =======>  "+ctClass.toString()+"   annotation ======>"+classAnnotation.toString())
                        for (CtMethod method : ctClass.getDeclaredMethods()) {
                            HideMethod methodAnnotaion = method.getAnnotation(HideMethod.class)
                            if (methodAnnotaion != null) {
                                println("annotation  =======>"+methodAnnotaion.value())
                                if(methodAnnotaion.value()){
                                    println("remove method ======> "+method.getName()+"   annotation ======>"+methodAnnotaion.toString())
                                    ctClass.removeMethod(method)
                                }
                            }
                        }
                        ctClass.writeFile(path)
                        ctClass.detach()//释放
                    }
                } catch (Exception e) {
                }
            }
        }

    }
}
```





#### 2:ASM

##### 1：ASM 是什么？

一句话概述 ASM 就是 字节码修改器



##### 2：核心类：

ClassReader：读取calss 文件

ClassWriter ：写入class

ClassVisitror:访问class 属性，方法  



![img](../../../art/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%8B%E7%82%B9%E5%88%86%E4%BA%AB/-164266192033710.png)

##### 3：依赖库

```
implementation 'org.ow2.asm:asm:7.1'
implementation 'org.ow2.asm:asm-commons:7.1'
```

##### 4:基本使用 （给函数添加耗时统计）

java 原文件

```
//java 文件 onCreate 耗时
public class MainActivity extends AppCompatActivity {
    public MainActivity() {
    }

    protected void onCreate(Bundle savedInstanceState) {
        long var2 = System.currentTimeMillis();//开始时间
        
        super.onCreate(savedInstanceState);
        this.setContentView(layoutid);
        
        long var4 = System.currentTimeMillis();//结束时间
        System.out.println(this.getClass().getName() + " - method: onCreate run time : " + (var4 - var2));
    }
}
```

字节码文件：

```
// class version 52.0 (52)
// access flags 0x21
public class com/example/asmtest/MainActivity extends androidx/appcompat/app/AppCompatActivity {

  // compiled from: MainActivity.java
  // access flags 0x19
  public final static INNERCLASS com/example/asmtest/R$layout com/example/asmtest/R layout

  // access flags 0x1
  public <init>()V
   L0
    LINENUMBER 7 L0
    ALOAD 0
    INVOKESPECIAL androidx/appcompat/app/AppCompatActivity.<init> ()V
    RETURN
   L1
    LOCALVARIABLE this Lcom/example/asmtest/MainActivity; L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 0x4
  protected onCreate(Landroid/os/Bundle;)V
    // parameter  savedInstanceState
   L0
    LINENUMBER 17 L0
    INVOKESTATIC java/lang/System.currentTimeMillis ()J//在这里将要添加的
    LSTORE 2
   L1
    LINENUMBER 11 L1
    ALOAD 0
    ALOAD 1
    INVOKESPECIAL androidx/appcompat/app/AppCompatActivity.onCreate (Landroid/os/Bundle;)V
   L2
    LINENUMBER 12 L2
    ALOAD 0
    LDC 2131427356
    INVOKEVIRTUAL com/example/asmtest/MainActivity.setContentView (I)V
   L3                                                    //从这里将要添加的
    LINENUMBER 13 L3
    LINENUMBER 18 L3
    INVOKESTATIC java/lang/System.currentTimeMillis ()J
    LSTORE 4
   L4
    LINENUMBER 19 L4
    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
    NEW java/lang/StringBuilder
    DUP
    INVOKESPECIAL java/lang/StringBuilder.<init> ()V
    ALOAD 0
    INVOKEVIRTUAL java/lang/Object.getClass ()Ljava/lang/Class;
    INVOKEVIRTUAL java/lang/Class.getName ()Ljava/lang/String;
    INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
    LDC " - method: onCreate run time : "
    INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
    LLOAD 4
    LLOAD 2
    LSUB
    INVOKEVIRTUAL java/lang/StringBuilder.append (J)Ljava/lang/StringBuilder;
    INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V
    RETURN
   L5
    LOCALVARIABLE this Lcom/example/asmtest/MainActivity; L1 L5 0
    LOCALVARIABLE savedInstanceState Landroid/os/Bundle; L1 L5 1
    MAXSTACK = 6
    MAXLOCALS = 6
}
```

对照字节码文件：输出asm 代码添加

```
 /**
     * 添加监控代码到class 文件
     * @param file
     */
    static void addMonitorByteCode(File file) {
        if(file == null || !file.exists()){
            return
        }
        def fileInputStream = new FileInputStream(file)
        def classReader = new ClassReader(fileInputStream)//输入文件流
        def classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_FRAMES);//写入读文件
        def classVisitor = new ChangeVisitor(Opcodes.ASM7,classWriter)//访问文件- 参数1：协议
        classReader.accept(classVisitor,ClassReader.EXPAND_FRAMES)//开始访问
            //修改完成 开始写入源文件
        byte[] data = classWriter.toByteArray()
        fileInputStream.close()
        def fileOutputStream = new FileOutputStream(file)
        fileOutputStream.write(data)
        fileOutputStream.close()
    }

//关键类  class 访问器
    static class ChangeVisitor extends ClassVisitor {

        ChangeVisitor(int api,ClassVisitor classVisitor) {
            super(api, classVisitor);
        }

        //方法访问回调
        @Override
        MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
            MethodVisitor methodVisitor = super.visitMethod(access, name, desc, signature, exceptions);
            if (name.equals("<init>") || name.equals("<clinit>")) {//init clinit 构造方法
                return methodVisitor;
            }
            //使用方法适配器。来确定方法进出 添加代码
            return new AdviceAdapterImpl(Opcodes.ASM7, methodVisitor, access, name, desc);
        }

        //注解
        @Override
        AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
            return super.visitAnnotation(descriptor, visible)
        }
    }


    static class AdviceAdapterImpl extends AdviceAdapter{

        protected AdviceAdapterImpl(int api, MethodVisitor methodVisitor, int access, String name, String descriptor) {
            super(api, methodVisitor, access, name, descriptor)
            System.out.println("AdviceAdapterImpl : name = "+name);
        }

        @Override
        void visitCode() {
            super.visitCode()
            System.out.println("AdviceAdapterImpl : 开始 name = "+name);
        }

        //进入方法，添加字节码
        @Override
        protected void onMethodEnter() {
            super.onMethodEnter()
            System.out.println("AdviceAdapterImpl : 进入 name = "+name);
            Label label2 = new Label();
            mv.visitLabel(label2);
            mv.visitLineNumber(17, label2);
            mv.visitMethodInsn(INVOKESTATIC, "java/lang/System", "currentTimeMillis", "()J", false);
            mv.visitVarInsn(LSTORE, 2);
        }

        //退出方法添加字节码
        @Override
        protected void onMethodExit(int opcode) {
            super.onMethodExit(opcode)
            System.out.println("AdviceAdapterImpl : 退出 name = "+name);
            Label label3 = new Label();
            mv.visitLabel(label3);
            mv.visitLineNumber(18, label3);
            mv.visitMethodInsn(INVOKESTATIC, "java/lang/System", "currentTimeMillis", "()J", false);
            mv.visitVarInsn(LSTORE, 4);
            Label label4 = new Label();
            mv.visitLabel(label4);
            mv.visitLineNumber(19, label4);
            mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
            mv.visitTypeInsn(NEW, "java/lang/StringBuilder");
            mv.visitInsn(DUP);
            mv.visitMethodInsn(INVOKESPECIAL, "java/lang/StringBuilder", "<init>", "()V", false);
            mv.visitVarInsn(ALOAD, 0);
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Object", "getClass", "()Ljava/lang/Class;", false);
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Class", "getName", "()Ljava/lang/String;", false);
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
            String methodMsg  = " - method: "+name+" run time : ";
            mv.visitLdcInsn(methodMsg);
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
            mv.visitVarInsn(LLOAD, 4);
            mv.visitVarInsn(LLOAD, 2);
            mv.visitInsn(LSUB);
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(J)Ljava/lang/StringBuilder;", false);
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "toString", "()Ljava/lang/String;", false);
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);
        }

        @Override
        void visitEnd() {
            super.visitEnd()
            System.out.println("AdviceAdapterImpl : 结束 name = "+name);
        }
    }
```

5：快捷方式：

![img](../../../art/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%8B%E7%82%B9%E5%88%86%E4%BA%AB/-164266192033711.png)



![img](../../../art/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%8B%E7%82%B9%E5%88%86%E4%BA%AB/-164266192033712.png)



```
package asm.com.example.asmtest;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.ConstantDynamic;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.TypePath;

public class MainActivityDump implements Opcodes {

    public static byte[] dump() throws Exception {

        ClassWriter classWriter = new ClassWriter(0);
        FieldVisitor fieldVisitor;
        MethodVisitor methodVisitor;
        AnnotationVisitor annotationVisitor0;

        classWriter.visit(V1_8, ACC_PUBLIC | ACC_SUPER, "com/example/asmtest/MainActivity", null, "androidx/appcompat/app/AppCompatActivity", null);

        classWriter.visitSource("MainActivity.java", null);

        classWriter.visitInnerClass("com/example/asmtest/R$layout", "com/example/asmtest/R", "layout", ACC_PUBLIC | ACC_FINAL | ACC_STATIC);

        {
            methodVisitor = classWriter.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
            methodVisitor.visitCode();
            Label label0 = new Label();
            methodVisitor.visitLabel(label0);
            methodVisitor.visitLineNumber(7, label0);
            methodVisitor.visitVarInsn(ALOAD, 0);
            methodVisitor.visitMethodInsn(INVOKESPECIAL, "androidx/appcompat/app/AppCompatActivity", "<init>", "()V", false);
            methodVisitor.visitInsn(RETURN);
            Label label1 = new Label();
            methodVisitor.visitLabel(label1);
            methodVisitor.visitLocalVariable("this", "Lcom/example/asmtest/MainActivity;", null, label0, label1, 0);
            methodVisitor.visitMaxs(1, 1);
            methodVisitor.visitEnd();
        }
        {
            methodVisitor = classWriter.visitMethod(ACC_PROTECTED, "onCreate", "(Landroid/os/Bundle;)V", null, null);
            methodVisitor.visitParameter("savedInstanceState", 0);
            methodVisitor.visitCode();
            Label label0 = new Label();
            methodVisitor.visitLabel(label0);
            methodVisitor.visitLineNumber(17, label0);
            methodVisitor.visitMethodInsn(INVOKESTATIC, "java/lang/System", "currentTimeMillis", "()J", false);
            methodVisitor.visitVarInsn(LSTORE, 2);
            Label label1 = new Label();
            methodVisitor.visitLabel(label1);
            methodVisitor.visitLineNumber(11, label1);
            methodVisitor.visitVarInsn(ALOAD, 0);
            methodVisitor.visitVarInsn(ALOAD, 1);
            methodVisitor.visitMethodInsn(INVOKESPECIAL, "androidx/appcompat/app/AppCompatActivity", "onCreate", "(Landroid/os/Bundle;)V", false);
            Label label2 = new Label();
            methodVisitor.visitLabel(label2);
            methodVisitor.visitLineNumber(12, label2);
            methodVisitor.visitVarInsn(ALOAD, 0);
            methodVisitor.visitLdcInsn(new Integer(2131427356));
            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, "com/example/asmtest/MainActivity", "setContentView", "(I)V", false);
            Label label3 = new Label();
            methodVisitor.visitLabel(label3);
            methodVisitor.visitLineNumber(13, label3);
            methodVisitor.visitLineNumber(18, label3);
            methodVisitor.visitMethodInsn(INVOKESTATIC, "java/lang/System", "currentTimeMillis", "()J", false);
            methodVisitor.visitVarInsn(LSTORE, 4);
            Label label4 = new Label();
            methodVisitor.visitLabel(label4);
            methodVisitor.visitLineNumber(19, label4);
            methodVisitor.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
            methodVisitor.visitTypeInsn(NEW, "java/lang/StringBuilder");
            methodVisitor.visitInsn(DUP);
            methodVisitor.visitMethodInsn(INVOKESPECIAL, "java/lang/StringBuilder", "<init>", "()V", false);
            methodVisitor.visitVarInsn(ALOAD, 0);
            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Object", "getClass", "()Ljava/lang/Class;", false);
            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Class", "getName", "()Ljava/lang/String;", false);
            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
            methodVisitor.visitLdcInsn(" - method: onCreate run time : ");
            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
            methodVisitor.visitVarInsn(LLOAD, 4);
            methodVisitor.visitVarInsn(LLOAD, 2);
            methodVisitor.visitInsn(LSUB);
            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(J)Ljava/lang/StringBuilder;", false);
            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "toString", "()Ljava/lang/String;", false);
            methodVisitor.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);
            methodVisitor.visitInsn(RETURN);
            Label label5 = new Label();
            methodVisitor.visitLabel(label5);
            methodVisitor.visitLocalVariable("this", "Lcom/example/asmtest/MainActivity;", null, label1, label5, 0);
            methodVisitor.visitLocalVariable("savedInstanceState", "Landroid/os/Bundle;", null, label1, label5, 1);
            methodVisitor.visitMaxs(6, 6);
            methodVisitor.visitEnd();
        }
        classWriter.visitEnd();

        return classWriter.toByteArray();
    }
}
```

##### 5：eg 

方法耗时

```
/**
     * 添加监控代码到class 文件
     * @param file
     */
    static void addMonitorByteCode(File file) {
        if(file == null || !file.exists()){
            return
        }
        def fileInputStream = new FileInputStream(file)
        def classReader = new ClassReader(fileInputStream)//输入文件流
        def classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_FRAMES);//写入读文件
        def classVisitor = new ChangeVisitor(Opcodes.ASM7,classWriter)//访问文件- 参数1：协议
        classReader.accept(classVisitor,ClassReader.EXPAND_FRAMES)//开始访问
            //修改完成 开始写入源文件
        byte[] data = classWriter.toByteArray()
        fileInputStream.close()
        def fileOutputStream = new FileOutputStream(file)
        fileOutputStream.write(data)
        fileOutputStream.close()
    }

//关键类  class 访问器
    static class ChangeVisitor extends ClassVisitor {

        ChangeVisitor(int api,ClassVisitor classVisitor) {
            super(api, classVisitor);
        }

        //方法访问回调
        @Override
        MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
            MethodVisitor methodVisitor = super.visitMethod(access, name, desc, signature, exceptions);
            if (name.equals("<init>") || name.equals("<clinit>")) {//init clinit 构造方法
                return methodVisitor;
            }
            //使用方法适配器。来确定方法进出 添加代码
            return new AdviceAdapterImpl(Opcodes.ASM7, methodVisitor, access, name, desc);
        }

        //注解
        @Override
        AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
            return super.visitAnnotation(descriptor, visible)
        }
    }


    static class AdviceAdapterImpl extends AdviceAdapter{

        protected AdviceAdapterImpl(int api, MethodVisitor methodVisitor, int access, String name, String descriptor) {
            super(api, methodVisitor, access, name, descriptor)
            System.out.println("AdviceAdapterImpl : name = "+name);
        }

        @Override
        void visitCode() {
            super.visitCode()
            System.out.println("AdviceAdapterImpl : 开始 name = "+name);
        }

        //进入方法，添加字节码
        @Override
        protected void onMethodEnter() {
            super.onMethodEnter()
            System.out.println("AdviceAdapterImpl : 进入 name = "+name);
            Label label2 = new Label();
            mv.visitLabel(label2);
            mv.visitLineNumber(17, label2);
            mv.visitMethodInsn(INVOKESTATIC, "java/lang/System", "currentTimeMillis", "()J", false);
            mv.visitVarInsn(LSTORE, 2);
        }

        //退出方法添加字节码
        @Override
        protected void onMethodExit(int opcode) {
            super.onMethodExit(opcode)
            System.out.println("AdviceAdapterImpl : 退出 name = "+name);
            Label label3 = new Label();
            mv.visitLabel(label3);
            mv.visitLineNumber(18, label3);
            mv.visitMethodInsn(INVOKESTATIC, "java/lang/System", "currentTimeMillis", "()J", false);
            mv.visitVarInsn(LSTORE, 4);
            Label label4 = new Label();
            mv.visitLabel(label4);
            mv.visitLineNumber(19, label4);
            mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
            mv.visitTypeInsn(NEW, "java/lang/StringBuilder");
            mv.visitInsn(DUP);
            mv.visitMethodInsn(INVOKESPECIAL, "java/lang/StringBuilder", "<init>", "()V", false);
            mv.visitVarInsn(ALOAD, 0);
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Object", "getClass", "()Ljava/lang/Class;", false);
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Class", "getName", "()Ljava/lang/String;", false);
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
            String methodMsg  = " - method: "+name+" run time : ";
            mv.visitLdcInsn(methodMsg);
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;", false);
            mv.visitVarInsn(LLOAD, 4);
            mv.visitVarInsn(LLOAD, 2);
            mv.visitInsn(LSUB);
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "append", "(J)Ljava/lang/StringBuilder;", false);
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "toString", "()Ljava/lang/String;", false);
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);
        }

        @Override
        void visitEnd() {
            super.visitEnd()
            System.out.println("AdviceAdapterImpl : 结束 name = "+name);
        }
    }
```





![img](../../../art/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%8B%E7%82%B9%E5%88%86%E4%BA%AB/-164266192033713.png)

![img](../../../art/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%8B%E7%82%B9%E5%88%86%E4%BA%AB/-164266192033714.png)



#### 3：Aspectj（比较优秀的字节码插桩器）

##### 1：Aspect 能做什么？

通常来说，AOP都是为一些相对基础且固定的需求服务，实际常见的场景大致包括：

- 统计埋点

- 日志打印/打点

- 数据校验

- 行为拦截

- 性能监控

- 动态权限控制

##### 2：Aspect 库 获取：

成熟框架：

https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx

https://github.com/JakeWharton/hugo 较为古老

Maven 仓库：

https://search.maven.org/artifact/org.aspectj/aspectjrt

##### 3：依赖

```
implementation 'org.aspectj:aspectjrt:1.9.7'
```

##### 4：基本语义：

- @Aspect 用它声明一个类，表示一个需要执行的切面。

- @Pointcut 声明一个切点。其中Point 连接点

- @Before/@After/@Around/…（统称为Advice类型） 声明在切点前、后、中执行切面代码。



![img](../../../art/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%8B%E7%82%B9%E5%88%86%E4%BA%AB/-164266192033715.png)

###### **Join Point**

上面的例子中少讲了一个连接点的概念，连接点表示可织入代码的点，它属于Pointcut的一部分。由于语法内容较多，实际使用过程中我们可以参考[语法手册](https://link.juejin.cn/?target=https://github.com/hiphonezhu/Android-Demos/blob/master/AspectJDemo/AspectJ.pdf)，我们列出其中一部分Join Point：

无法复制加载中的内容

###### **Pointcut**

Pointcuts是具体的切入点，基本上Pointcuts 是和 Join Point 相对应的。

无法复制加载中的内容

除了上面与 Join Point 对应的选择外，Pointcuts 还有其他选择方法。

无法复制加载中的内容

规则

**@Aspect的pointcut**

申明方式主要包含2个部分：

- Pointcut Expression
  - 真正指定Pointcut的地方。

- 表达式中可以&& || ！这些逻辑运算符

- Pointcut Signature
  - 需要一个定义的方法做为载体，这个方法必须是void类型

- 如果该方法是public的，那么这个pointcut可以被其他的Aspect引用，如果是private那么只能被当前Aspect类引用。

Aspectj的pointcut表述语言中有很多标志符，但是SpringAOP只能是用少数的几种，因为Spring只对方法级别的pointcut。

- execution
  - 规定格式：

```
execution(<修饰符模式>?<返回类型模式><方法名模式>(<参数模式>)<异常模式>?)
```

- 只有返回类型，方法名，参数模式是必须的，其他的可以省略。

- 这里面我们可以使用2种通配符
  - `*` 匹配任意的意思

- `..`当前包以及子包里面所有的类

- within
  - 只接受类型的声明，会匹配指定类型下面所有的Jointpoint。对SpringAOP来说及，匹配这个类下面所有的方法。

- this和target
  - this指代方法调用方，target指被调用方。

- this(o1) && this(o2) 即表示当o1类型对象，调用o2类型对象的方法的时候，才会匹配。

- args
  - 指定参数的类型，当调用方法的参数类型匹配就会捕捉到。

- @within
  - 指定某些注解，如果某些类上面有指定的注解，那么这个类里面所有的方法都将被匹配。

- @target
  - 目标类是指定注解的时候，就会被匹配，SpringAOP中和@within没什么区别，只不过@within是静态匹配，@target是运行时动态匹配。

- @args
  - 如果传入的参数的类型 有其指定的注解类型，那么就被匹配。

- @annotation
  - 系统中所有的对象的类方法中，有注解了指定注解的方法，都会被匹配。

这些注解的pointcut在spring内部最终都会转为具体的pointcut对象。

**@AspectJ形式的Advice**

主要就是一些Advice的注解：

- @Before
  - 想要获取方法的参数等信息：可以2种方法
    - 第一个参数设置为JoinPoint，这个参数必须要放在第一个位置，并且除了Around Advice和Introduction不可以用它，其他的Advice都可以使用。

- args标志符绑定（不常用）

- @AfterReturning
  - 有一个独特属性：returning，可以获取到方法返回值。

- @AfterThrowing
  - 有一个独特属性：throwing 可以接受抛出的异常对象。

- @After（也叫finally）
  - 一般做资源的释放工作的

- @Around
  - 它的第一个参数必须是ProceedingJoinPoint类型，且必须指定。通过ProceedingJoinPoint的proceed()方法执行原方法的调用。

- proceed()方法需要传入参数，则传入一个Object[]数组。

- @DeclareParents
  - 处理Introduction的，不多描述了。



参考使用

```
@Aspect
public class PointcutCategory {
   /**
    * 匹配任意返回值，任意方法，（任意参数）
    */
   @Around("execution(* *(..))")
   public Object weaveAllMethod(ProceedingJoinPoint joinPoint) throws Throwable{
   }
   
   /**
    * 匹配任意返回值，任意名称，（任意参数)的公共方法
    */
   @Pointcut("execution(public * *(..))")
   public void publicMethodPointcut() {

   }
  
   /**
    * 匹配 com.aspectj.practice 包及其子包中的所有方法
    */
   @Pointcut("within(com.aspectj.practice..*)")
   public void packagePointcut() {

   }
   
   /**
    * 匹配MainActivity类及其子类的所有方法
    */
   @Pointcut("within(com.aspectj.practice.MainActivity+)")
   public void subclassPointcut() {

   }
   
   /**
    * 匹配类 MainActivity 的所有方法
    */
   @Pointcut("within(com.aspectj.practice.SubMainActivity)")
   public void classPointcut() {

   }
   
   /**
    * 匹配所有实现 User 的类的所有方法
    */
   @Pointcut("within(com.aspectj.practice.framework.interfaces.User+)")
   public void interfaceIpm() {

   }
   
   /**
    * 匹配 test 开头，任意返回值的方法
    */
   @Pointcut("execution(* test*())")
   public void withSetPrefixPointcut() {

   }

   /**
    * 匹配 userImp 的所有方法
    */
   @Pointcut("execution(* com.aspectj.practice.userImp.*(..))")
   public void allMethodPointcut() {

   }

   /**
    * 匹配 userImp 的所有私有方法
    */
   @Pointcut("execution(private * com.aspectj.practice.userImp.*(..))")
   public void allPrivateMethodPointcut() {

   }
   
   /**
    * 匹配 userImp 的所有公有方法
    */
   @Pointcut("execution(public * com.aspectj.practice.userImp.*(int, ..))")
   public void allPublicMethodWithIntPointcut() {

   }
   
   /**
    * @within 匹配标注了注解 ClassAnnotation 的类及其子孙的所有方法
    */
   @Pointcut("@within(com.aspectj.annotation.ClassAnnotation)")
   public void withAnnotationClassPointcut() {

   }
   
   /**
    * 匹配使用了注解 MethodAnnotation 的方法
    */
   @Pointcut("@annotation(com.aspectj.annotation.MethodAnnotation)")
   public void withAnnotationMethodPointcut() {

   }

   /**
    * 匹配使用了注解 MethodAnnotation 的方法
    */
   @Pointcut("execution(@com.aspectj.annotation.MethodAnnotation * *(..))")
   public void withAnnotationMethodPointcut2() {

   }
   
   /**
    * 匹配任意实现了接口User的目标对象的方法并且方法使用了注解 MethodAnnotation
    */
   @Pointcut("target(com.aspectj.practice.framework.interfaces.User) && @annotation(com.aspectj.annotation.MethodAnnotation)")
   public void withOperatorPointcut() {

   }
   
   /**
    * 匹配任意实现了接口User的目标对象的方法并且方法名称为 add
    */
   @Pointcut("target(com.aspectj.practice.framework.interfaces.User) && execution(* com.aspectj.practice.framework.interfaces.User.add(..))")
   public void withOperatorAddNamePointcut() {

   }
   
   @Pointcut("call(* com.aspectj.practice.framework.interfaces.User.*(..))")
   public void methodCallPointcut() {
   
   }
   
   /**
    * 匹配 MemberDto 的属性 userName 的赋值
    */
   @Pointcut("set(java.lang.String com.aspectj.practice.dto.MemberDto.userName)")
   public void fieldSetPointCut() {

   }
   
   /**
    * 匹配 MemberDto 的属性 userName的获取
    */
   @Pointcut("get(java.lang.String com.aspectj.practice.dto.MemberDto.userName)")
   public void fieldGetPointCut() {

   }
   
   /**
    * 匹配 MemberDto 构造函数
    */
   @Pointcut("call(com.aspectj.practice.dto.MemberDto.new(..))")
   public void constructorCallPointcut() {

   }
}
```

##### 5：集成

忒别注意配置 依赖，要不然编译不过，很麻烦，自己掉坑里好几次



1：Porject 配置：

```
// Top-level build file where you can add configuration options common to all sub-projects/modules.
buildscript {
    repositories {
        maven {
            url uri('./repos')
        }
        mavenLocal()
        google()
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:4.2.2'
        classpath 'com.miadapm.plugin:miadapm:1.0.0'
        classpath 'org.aspectj:aspectjtools:1.9.7'//引入Tools工具
    }
}

allprojects {
    repositories {
        maven {
            url uri('./repos')
        }
        mavenLocal()
        google()
        jcenter()
    }
}


task clean(type: Delete) {
    delete rootProject.buildDir
}
```



2:示例使用插件方式，也可以自己集成在项目中

![img](../../../art/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%8B%E7%82%B9%E5%88%86%E4%BA%AB/-164266192033716.png)

app 配置：

```
apply plugin:'com.miadapm.plugin' //唯一配置，进配置插件
```

插件配置：

```
package com.miadapm.plugin;

import com.android.build.gradle.AppExtension
import com.miadapm.plugin.asm.AsmTransform
import org.aspectj.bridge.IMessage
import org.aspectj.bridge.MessageHandler
import org.aspectj.tools.ajc.Main
import org.gradle.api.Plugin;
import org.gradle.api.Project
import org.gradle.api.tasks.compile.JavaCompile

public class MiAdApmPlugin implements Plugin<Project> {

    @Override
    public void apply(Project project) {
//        AsmStart(project)
        AspectJStart(project)
    }


    private void AsmStart(Project project) {
        System.out.println("================ ASM Plugin start =============");
        AppExtension appExtension = (AppExtension) project.getProperties().get("android");
        appExtension.registerTransform(new AsmTransform(), Collections.EMPTY_LIST);
    }

    private void AspectJStart(Project hostProject) {
        System.out.println("================ AspectJ Plugin start =============");
        //代码引用
        hostProject.dependencies {
            //引入工具及 切面规则
            implementation 'org.aspectj:aspectjrt:1.9.7'
            implementation project(path: ':miadaspect')
        }

        //扩展使用
//        project.extensions.create('hugo', HugoExtension)

        final def log = hostProject.logger
        final def variants = hostProject.android.applicationVariants

        variants.all { variant ->
            if (!variant.buildType.isDebuggable()) {
                log.debug("Skipping non-debuggable build type '${variant.buildType.name}'.")
                return
            }
            JavaCompile javaCompile = variant.javaCompile
            javaCompile.doLast {
                String[] args = ["-showWeaveInfo",
                                 "-1.9",
                                 "-inpath", javaCompile.destinationDir.toString(),
                                 "-aspectpath", javaCompile.classpath.asPath,
                                 "-d", javaCompile.destinationDir.toString(),
                                 "-classpath", javaCompile.classpath.asPath,
                                 "-bootclasspath", hostProject.android.bootClasspath.join(File.pathSeparator)]
                log.debug "ajc args: " + Arrays.toString(args)
                MessageHandler handler = new MessageHandler(true)
                new Main().run(args, handler)
                for (IMessage message : handler.getMessages(null, true)) {
                    switch (message.getKind()) {
                        case IMessage.ABORT:
                        case IMessage.ERROR:
                        case IMessage.FAIL:
                            log.error message.message, message.thrown
                            break
                        case IMessage.WARNING:
                            log.warn message.message, message.thrown
                            break
                        case IMessage.INFO:
                            log.info message.message, message.thrown
                            break
                        case IMessage.DEBUG:
                            log.debug message.message, message.thrown
                            break
                    }
                }
            }
        }
    }
}
```

3：切面配置：

```
apply plugin: 'com.android.library'
apply plugin: 'maven'

android {
    compileSdkVersion 30
    buildToolsVersion "30.0.0"

    defaultConfig {
        minSdkVersion 14
        targetSdkVersion 30
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        consumerProguardFiles "consumer-rules.pro"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}

dependencies {
    implementation 'org.aspectj:aspectjrt:1.9.7'
}

def group='com.miadapm.aspect' //组
def version='1.0.0' //版本
def artifactId='methodtime' //唯一标示


//将插件打包上传到本地maven仓库
uploadArchives {
    repositories {
        mavenDeployer {
            pom.groupId = group
            pom.artifactId = artifactId
            pom.version = version
            //指定本地maven的路径，在项目根目录下
            repository(url: uri('../repos'))
        }
    }
}
import org.aspectj.bridge.IMessage
import org.aspectj.bridge.MessageHandler
import org.aspectj.tools.ajc.Main
final def log = project.logger

android.libraryVariants.all{ variant ->
    if (!variant.buildType.isDebuggable()) {
        log.debug("Skipping non-debuggable build type '${variant.buildType.name}'.")
        return
    }

    JavaCompile javaCompile = variant.javaCompiler
    javaCompile.doLast {
        String[] args = ["-showWeaveInfo",
                         "-1.9",
                         "-inpath", javaCompile.destinationDir.toString(),
                         "-aspectpath", javaCompile.classpath.asPath,
                         "-d", javaCompile.destinationDir.toString(),
                         "-classpath", javaCompile.classpath.asPath,
                         "-bootclasspath", project.android.bootClasspath.join(File.pathSeparator)]
        log.debug "ajc args: " + Arrays.toString(args)

        MessageHandler handler = new MessageHandler(true)
        new Main().run(args, handler)
        for (IMessage message : handler.getMessages(null, true)) {
            switch (message.getKind()) {
                case IMessage.ABORT:
                case IMessage.ERROR:
                case IMessage.FAIL:
                    log.error message.message, message.thrown
                    break
                case IMessage.WARNING:
                    log.warn message.message, message.thrown
                    break
                case IMessage.INFO:
                    log.info message.message, message.thrown
                    break
                case IMessage.DEBUG:
                    log.debug message.message, message.thrown
                    break
            }
        }
    }
}
```

##### 6：eg

方法耗时：activiy Oncreate 耗时

```
@Aspect
public class AspectAdMethodTime {

    @Pointcut("execution(* com.example.asmtest.MainActivity.onCreate(..))")
    public void callMethod() {
    }

    @Around("callMethod()")
    public void beforeMethodCall(ProceedingJoinPoint joinPoint) {
        Log.e("AspectJ", "before" );
        long startNanoTime = System.nanoTime();
        try {
            Object proceed = joinPoint.proceed();
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        Log.e("AspectJ", "after" );
        long stopNanoTime = System.nanoTime();
        Log.e("AspectJ","method time = "+(stopNanoTime - startNanoTime));
    }
}
```

app：源文件：

![img](../../../art/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%8B%E7%82%B9%E5%88%86%E4%BA%AB/-164266192033717.png)

![img](../../../art/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%8B%E7%82%B9%E5%88%86%E4%BA%AB/-164266192033718.png)



# 参考资料：

https://tech.meituan.com/2019/08/15/mtflexbox-automation-buried-point-exploration.html

https://juejin.cn/post/6868148850302844941

https://mp.weixin.qq.com/s/0dHKu5QIBL_4S7Tum-qW2Q

https://tech.meituan.com/2017/03/02/mt-mobile-analytics-practice.html

https://tech.meituan.com/2017/03/02/mt-mobile-analytics-practice.html

https://blog.csdn.net/xiaxiangnanxp1989/article/details/81701372