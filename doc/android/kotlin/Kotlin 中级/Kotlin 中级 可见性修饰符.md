# Kotlin 中级篇（三）:可见性修饰符

## 一、 四种修饰符的说明

- `public`修饰符表示 *公有* 。此修饰符的范围最大。当不声明任何修饰符时，系统会默认使用此修饰符。
- `internal`修饰符表示 *模块* 。对于`模块`的范围在下面会说明。
- `protected`修饰符表示 *私有`+`子类*。值得注意的是，此修饰符不能用于`顶层`声明，在下面可以看到。
- `private`修饰符表示 *私有* 。此修饰符的范围最小，即可见性范围最低。

## 二、在不同场景下各个修饰符声明的范围讲解

> 对于可见性修饰符来说，不管是`Java`还是`Kotlin`，在不同的场景下用可见性修饰符修饰过的变量、函数、属性等都有不同的引用范围。

##### 2.1、在包(`package`)中声明，即顶层声明的情况

> 在顶层申明中分为下面两种情况：
>
> - 在同一个文件中访问的情况
> - 在不同文件中访问的情况

**2.1.1、测试同一个文件中声明不同的修饰符的范围**\

![img](../../../../art/Kotlin%20%E4%B8%AD%E7%BA%A7%20%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6/dbdf73b1b3c048c1bbfcf8700014311atplv-k3u1fbpfcp-watermark.webp)

在同一个文件中的访问情况

**2.1.2、测试不同文件中声明不同的修饰符的范围**\

![img](../../../../art/Kotlin%20%E4%B8%AD%E7%BA%A7%20%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6/10f414ae79fe420795fab2769011017etplv-k3u1fbpfcp-watermark.webp)

在不同文件中的访问情况

**2.1.3、小结**

> - 在顶层情况下声明的变量、方法、类、接口等，不能使用`protected`修饰符。
> - `public`修饰符可省略，因为它是系统默认的。
> - 在同一文件下，用任意修饰符都可以访问，当然此处除开`protected`修饰符
> - 在不同文件下，只能访问`public`、`internal`修饰符修饰的变量、方法等
> - 上边只演示了在顶层声明方法的情况，不过声明其他的也是一样的。

##### 2.2、在类(`class`)和接口(`interface`)中声明的情况

> - 在类中声明的情况和在接口中声明的情况是完全不相同的。

**2.2.1、测试在类中声明的情况**\

![img](../../../../art/Kotlin%20%E4%B8%AD%E7%BA%A7%20%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6/4f5f1b36a39941f1bc59acc8b4f54925tplv-k3u1fbpfcp-watermark.webp)

在类中声明的情况

**2.2.2、测试在接口中声明的情况**

**在接口中声明的情况**\

![image.png](../../../../art/Kotlin%20%E4%B8%AD%E7%BA%A7%20%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6/b3dc3f50d67b4a679599f8d456194a8etplv-k3u1fbpfcp-watermark.webp)

**使用接口中声明的属性**\

![img](../../../../art/Kotlin%20%E4%B8%AD%E7%BA%A7%20%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6/0c08a22f7f71483db9df51749193d518tplv-k3u1fbpfcp-watermark.webp)

**2.2.3、小结**

> - 在类中声明属性、方法等，可以使用任意修饰符修饰。并且在类中的任意位置都能访问各个修饰符修饰的属性、方法等。
> - 在类外，只能访问由`public`、`internal`修饰符修饰的属性、方法。此情况不管是不是在同一个文件中去操作。
> - 在接口中声明的情况下，只能由`public`修饰符修饰属性。方法可由`public`、`private`两个修饰符去修饰，但是，用`private`修饰符修饰符修饰的方法不能被实现该接口的类重写。
> - 为了使用接口中由`public`修饰符修饰的属性、方法等。只能定义一个类去实现该接口，然后重写其属性、方法。这样就能在可在类中或类外去操作。

**2.3、在构造函数中声明的情况**\

![img](../../../../art/Kotlin%20%E4%B8%AD%E7%BA%A7%20%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6/915af498a3f4437b824615a3fb0d2factplv-k3u1fbpfcp-watermark.webp)

> 在`Kotlin`中分为主构造函数，和副级或多级构造函数，当然在`Java`中也是存在的，只不过我们更习惯称其为`方法重载`。)。
> 故而，当我们在构造函数中声明的情况下，如果是主构造函数的时候，是和在类(`class`)中声明的情况是一样的。如果是主构造函数的时候，则是和在局部声明的情况是一样的。

**2.4、局部声明的情况**

> 在局部声明的情况下，只能使用`public`修饰符修饰的变量。并且在变量只能在局部这个范围内使用，出了这个范围后就访问不到了。\
>
> ![img](../../../../art/Kotlin%20%E4%B8%AD%E7%BA%A7%20%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6/84f3e898d14848a891e19c0c8bbfc599tplv-k3u1fbpfcp-watermark.webp)

## 三、与`Java`中的可见性修饰符的对比

> - `Java`中的可见性修饰符和`Koltin`中的可见性修饰符还是很有几点不同之处的：
>   1、 四种修饰符的不同。`Koltin`的四种修饰符（`public、interna、protected、private`），`Java`的的四种修饰符（`public、protected、privavte、default（即不使用任何修饰符）`）。
>   2、默认修饰符的不同。`Kotlin`的默认修饰符为`public`，`Java`的默认修饰符为`default`。